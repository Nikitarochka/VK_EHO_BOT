# VK_EHO_BOT
# VK Community Echo Bot

Я разработал этого бота для сообщества ВКонтакте, чтобы он отвечал пользователям, пересылая их исходные сообщения с вложениями (фото и документы). Такой подход позволил обойти ограничения токенов сообществ, связанные с повторной загрузкой файлов.

## Особенности

- **Приветствие:** при первом общении бот отправляет приветственное сообщение и сохраняет пользователя в базе данных.
- **Эхо-сообщения:** если пользователь отправляет фото или документ, бот пересылает исходное сообщение (включающее вложения) обратно отправителю.
- **Простота установки:** используются Docker и docker-compose для быстрого развёртывания проекта.

## Установка и запуск

### Предварительные требования

- [Docker](https://www.docker.com/) должен быть установлен в вашей системе.
- Git для клонирования репозитория.

### Инструкция по установке

1. **Клонируйте репозиторий:**
   git clone https://github.com/your_username/vk-bot.git
   cd vk-bot

Создайте файл .env в корне проекта и заполните его следующим образом (файл не должен попадать в репозиторий):
- VK_GROUP_TOKEN=your_vk_group_token_here
- VK_GROUP_ID=your_vk_group_id_here
- DATABASE_URL=postgresql+psycopg2://postgres:postgres@db:5432/vk_bot_db
- RESET_DB=false

, где
- VK_GROUP_TOKEN – токен вашего сообщества (убедитесь, что он имеет права на работу с сообщениями, фотографиями и документами).
- VK_GROUP_ID – идентификатор вашего сообщества.
- DATABASE_URL – строка подключения к PostgreSQL.
- RESET_DB – если установлено в true, база данных будет очищаться при запуске.

## СТРУКТУРА ПРОЕКТА
- VK Backend ML/
- ├── app
- │   ├── __init__.py        # Инициализация пакета
- │   ├── config.py          # Чтение переменных окружения
- │   ├── database.py        # Инициализация базы данных
- │   ├── models.py          # Определение модели пользователей
- │   ├── handlers.py        # Обработка входящих сообщений
- │   └── main.py            # Точка входа – запуск бота
- ├── requirements.txt       # Зависимости проекта
- ├── Dockerfile             # Инструкция для сборки Docker-образа
- ├── docker-compose.yml     # Конфигурация для Docker Compose
- └── .env                   # Файл переменных окружения (локальный)

# ЗАПУСК
- скачайте проект
  
- Зайдите в ваш терминал вызовом WIN + R

- Пропишите cmd

- Пропишите путь к VK Backend M cd './VK Backend ML'
  
- Запустите контейнеры: docker-compose up --build

После успешного запуска в консоли появится сообщение:
Бот запущен. Ожидание событий...

# НЕОБЯЗАТЕЛЬНО ДЛЯ ЧТЕНИЯ
## История разработки и альтернативные реализации

В процессе разработки я экспериментировал с несколькими подходами для реализации эхо-функционала:

1. Прямая отправка вложения по ID
Реализация:
Я пытался использовать вложения, полученные в событии (в виде словаря с ключами вида attach1_type и attach1), просто добавляя префикс ("photo" или "doc") к значению. Затем отправлял сообщение с этим вложением.

Почему не подошло:
В сообщениях сообщества вложения приходят в виде минимальных данных, принадлежащих отправителю, а не сообществу. Из-за этого повторное отправление такого ID не отображало фото или документ.

2. Повторная загрузка вложения
Реализация:
Я реализовывал вариант, где бот получал полную информацию о сообщении (с использованием метода messages.getById), извлекал подробные данные о вложении (например, массив sizes для фото), скачивал файл по URL, сохранял его во временный файл и затем повторно загружал через VkUpload. После этого бот отправлял новое сообщение с загруженным вложением.

Почему не подошло:
Данный подход столкнулся с ограничениями токенов сообществ: даже при наличии максимальных прав возникали ошибки доступа (Access Denied) при вызове методов для повторной загрузки. Ограничения токенов не позволяли корректно работать с такими методами.

Итоговая реализация: Пересылка исходного сообщения
Реализация:
В конечном варианте я решил использовать пересылку исходного сообщения через параметр forward_messages метода messages.send. Этот подход позволяет переслать исходное сообщение (с вложениями) обратно отправителю без необходимости скачивать и повторно загружать файлы.

Почему выбран:

Обход ограничений: Такой способ не требует повторной загрузки, что позволяет обойти ограничения токенов сообществ.
Простота реализации: Пересылка исходного сообщения реализуется одной строкой кода и не требует дополнительной обработки файлов.
Приемлемость: Хотя пользователь получает пересланное сообщение, а не «свежезагруженное» фото от имени сообщества, для целей эхо-бота это вполне приемлемо.
